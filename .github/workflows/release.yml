name: Build and Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.5.0) - without v prefix'
        required: true
        type: string

# Ensure only one release runs at a time - subsequent releases queue
concurrency:
  group: release
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  build:
    strategy:
      fail-fast: true  # Stop all builds if one fails
      matrix:
        include:
          - platform: macos-14
            args: '--target aarch64-apple-darwin'
            name: macOS-arm64
            arch: aarch64
            rust_targets: aarch64-apple-darwin
          - platform: macos-latest
            args: '--target x86_64-apple-darwin'
            name: macOS-x64
            arch: x86_64
            rust_targets: x86_64-apple-darwin
          - platform: ubuntu-22.04
            args: ''
            name: Linux-x64
            arch: x86_64
            rust_targets: ''
          - platform: windows-latest
            args: ''
            name: Windows-x64
            arch: x86_64
            rust_targets: ''

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version
        id: get_version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual trigger - use input version
            VERSION="${{ github.event.inputs.version }}"
          else
            # Tag trigger - extract from tag
            VERSION="${GITHUB_REF#refs/tags/v}"
          fi
          # Remove 'v' prefix if accidentally included
          VERSION="${VERSION#v}"
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Update version in package.json
        shell: bash
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '$VERSION';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "
          echo "Updated package.json to version $VERSION"

      - name: Update version in tauri.conf.json
        shell: bash
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          node -e "
            const fs = require('fs');
            const conf = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
            conf.version = '$VERSION';
            fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(conf, null, 2) + '\n');
          "
          echo "Updated tauri.conf.json to version $VERSION"

      - name: Update version in Cargo.toml
        shell: bash
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s/^version = \".*\"/version = \"$VERSION\"/" src-tauri/Cargo.toml
          else
            sed -i "s/^version = \".*\"/version = \"$VERSION\"/" src-tauri/Cargo.toml
          fi
          echo "Updated Cargo.toml to version $VERSION"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_targets }}

      - name: Install dependencies (Ubuntu)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install dependencies
        shell: bash
        run: pnpm install

      - name: Build Tauri app
        shell: bash
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: pnpm tauri build ${{ matrix.args }}

      - name: List built files (debug)
        shell: bash
        run: |
          echo "=== All bundle files ==="
          find src-tauri/target -path "*/release/bundle/*" -type f 2>/dev/null || true

      - name: Rename macOS update bundles with architecture
        if: contains(matrix.platform, 'macos')
        shell: bash
        run: |
          ARCH="${{ matrix.arch }}"
          # Find and rename .app.tar.gz and .app.tar.gz.sig files
          for f in $(find src-tauri/target -name "*.app.tar.gz" -type f 2>/dev/null); do
            dir=$(dirname "$f")
            base=$(basename "$f" .app.tar.gz)
            newname="${base}_${ARCH}.app.tar.gz"
            mv "$f" "$dir/$newname"
            echo "Renamed: $f -> $dir/$newname"
          done
          for f in $(find src-tauri/target -name "*.app.tar.gz.sig" -type f 2>/dev/null); do
            dir=$(dirname "$f")
            base=$(basename "$f" .app.tar.gz.sig)
            newname="${base}_${ARCH}.app.tar.gz.sig"
            mv "$f" "$dir/$newname"
            echo "Renamed: $f -> $dir/$newname"
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ matrix.name }}
          path: |
            src-tauri/target/**/release/bundle/**/*.dmg
            src-tauri/target/**/release/bundle/**/*.app.tar.gz
            src-tauri/target/**/release/bundle/**/*.app.tar.gz.sig
            src-tauri/target/**/release/bundle/**/*.deb
            src-tauri/target/**/release/bundle/**/*.AppImage
            src-tauri/target/**/release/bundle/**/*.AppImage.tar.gz
            src-tauri/target/**/release/bundle/**/*.AppImage.tar.gz.sig
            src-tauri/target/**/release/bundle/**/*.msi
            src-tauri/target/**/release/bundle/**/*.msi.zip
            src-tauri/target/**/release/bundle/**/*.msi.zip.sig
            src-tauri/target/**/release/bundle/**/*.exe
            src-tauri/target/**/release/bundle/**/*.nsis.zip
            src-tauri/target/**/release/bundle/**/*.nsis.zip.sig
          if-no-files-found: error

  release:
    needs: build  # Only runs after ALL builds succeed
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get version
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/v}"
          fi
          VERSION="${VERSION#v}"
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "TAG=v$VERSION" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: false

      - name: List downloaded artifacts
        run: |
          echo "=== Downloaded artifacts ==="
          find artifacts -type f | sort

      - name: Collect and normalize release files
        id: collect_files
        run: |
          mkdir -p release-files
          VERSION="${{ steps.get_version.outputs.VERSION }}"

          # Collect all release files
          find artifacts -type f \( \
            -name "*.dmg" -o \
            -name "*.app.tar.gz" -o \
            -name "*.app.tar.gz.sig" -o \
            -name "*.deb" -o \
            -name "*.AppImage" -o \
            -name "*.AppImage.tar.gz" -o \
            -name "*.AppImage.tar.gz.sig" -o \
            -name "*.msi" -o \
            -name "*.msi.zip" -o \
            -name "*.msi.zip.sig" -o \
            -name "*-setup.exe" -o \
            -name "*.nsis.zip" -o \
            -name "*.nsis.zip.sig" \
          \) -exec cp {} release-files/ \;

          echo "=== Files in release-files ==="
          ls -la release-files/

          # Identify update bundle files for each platform
          # macOS ARM64
          MACOS_ARM64_FILE=$(ls release-files/*_aarch64.app.tar.gz 2>/dev/null | head -1 || echo "")
          MACOS_ARM64_SIG=$(ls release-files/*_aarch64.app.tar.gz.sig 2>/dev/null | head -1 || echo "")

          # macOS x64
          MACOS_X64_FILE=$(ls release-files/*_x86_64.app.tar.gz 2>/dev/null | head -1 || echo "")
          MACOS_X64_SIG=$(ls release-files/*_x86_64.app.tar.gz.sig 2>/dev/null | head -1 || echo "")

          # Windows - prefer nsis.zip for updates
          WINDOWS_FILE=$(ls release-files/*.nsis.zip 2>/dev/null | grep -v ".sig" | head -1 || echo "")
          WINDOWS_SIG=$(ls release-files/*.nsis.zip.sig 2>/dev/null | head -1 || echo "")

          # Linux
          LINUX_FILE=$(ls release-files/*.AppImage.tar.gz 2>/dev/null | grep -v ".sig" | head -1 || echo "")
          LINUX_SIG=$(ls release-files/*.AppImage.tar.gz.sig 2>/dev/null | head -1 || echo "")

          # Output for next steps
          echo "MACOS_ARM64_FILE=$(basename "$MACOS_ARM64_FILE" 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "MACOS_ARM64_SIG=$(basename "$MACOS_ARM64_SIG" 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "MACOS_X64_FILE=$(basename "$MACOS_X64_FILE" 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "MACOS_X64_SIG=$(basename "$MACOS_X64_SIG" 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "WINDOWS_FILE=$(basename "$WINDOWS_FILE" 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "WINDOWS_SIG=$(basename "$WINDOWS_SIG" 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "LINUX_FILE=$(basename "$LINUX_FILE" 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "LINUX_SIG=$(basename "$LINUX_SIG" 2>/dev/null || echo '')" >> $GITHUB_OUTPUT

          echo "=== Identified update bundles ==="
          echo "macOS ARM64: $MACOS_ARM64_FILE (sig: $MACOS_ARM64_SIG)"
          echo "macOS x64: $MACOS_X64_FILE (sig: $MACOS_X64_SIG)"
          echo "Windows: $WINDOWS_FILE (sig: $WINDOWS_SIG)"
          echo "Linux: $LINUX_FILE (sig: $LINUX_SIG)"

      - name: Commit version bump and create tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          TAG="${{ steps.get_version.outputs.TAG }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Update version files
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '$VERSION';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "

          node -e "
            const fs = require('fs');
            const conf = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
            conf.version = '$VERSION';
            fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(conf, null, 2) + '\n');
          "

          sed -i "s/^version = \".*\"/version = \"$VERSION\"/" src-tauri/Cargo.toml

          # Update Cargo.lock by running cargo check
          cd src-tauri && cargo check --quiet 2>/dev/null || true && cd ..

          # Commit changes
          git add package.json src-tauri/tauri.conf.json src-tauri/Cargo.toml src-tauri/Cargo.lock 2>/dev/null || true
          git add package.json src-tauri/tauri.conf.json src-tauri/Cargo.toml

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No version changes to commit (version may already be correct)"
          else
            git commit -m "Release $TAG"
            git push origin HEAD:main
          fi

          # Create and push tag
          git tag "$TAG"
          git push origin "$TAG"

          echo "✅ Version bump committed and tag $TAG created"

      - name: Generate update manifest (latest.json)
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          TAG="${{ steps.get_version.outputs.TAG }}"
          PUB_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          REPO="${{ github.repository }}"

          # Get file names from previous step
          MACOS_ARM64_FILE="${{ steps.collect_files.outputs.MACOS_ARM64_FILE }}"
          MACOS_ARM64_SIG_FILE="${{ steps.collect_files.outputs.MACOS_ARM64_SIG }}"
          MACOS_X64_FILE="${{ steps.collect_files.outputs.MACOS_X64_FILE }}"
          MACOS_X64_SIG_FILE="${{ steps.collect_files.outputs.MACOS_X64_SIG }}"
          WINDOWS_FILE="${{ steps.collect_files.outputs.WINDOWS_FILE }}"
          WINDOWS_SIG_FILE="${{ steps.collect_files.outputs.WINDOWS_SIG }}"
          LINUX_FILE="${{ steps.collect_files.outputs.LINUX_FILE }}"
          LINUX_SIG_FILE="${{ steps.collect_files.outputs.LINUX_SIG }}"

          # Read signatures
          MACOS_ARM64_SIG=""
          MACOS_X64_SIG=""
          WINDOWS_SIG=""
          LINUX_SIG=""

          if [ -n "$MACOS_ARM64_SIG_FILE" ] && [ -f "release-files/$MACOS_ARM64_SIG_FILE" ]; then
            MACOS_ARM64_SIG=$(cat "release-files/$MACOS_ARM64_SIG_FILE")
            echo "✅ Found macOS ARM64 signature"
          else
            echo "⚠️ Missing macOS ARM64 signature file"
          fi

          if [ -n "$MACOS_X64_SIG_FILE" ] && [ -f "release-files/$MACOS_X64_SIG_FILE" ]; then
            MACOS_X64_SIG=$(cat "release-files/$MACOS_X64_SIG_FILE")
            echo "✅ Found macOS x64 signature"
          else
            echo "⚠️ Missing macOS x64 signature file"
          fi

          if [ -n "$WINDOWS_SIG_FILE" ] && [ -f "release-files/$WINDOWS_SIG_FILE" ]; then
            WINDOWS_SIG=$(cat "release-files/$WINDOWS_SIG_FILE")
            echo "✅ Found Windows signature"
          else
            echo "⚠️ Missing Windows signature file"
          fi

          if [ -n "$LINUX_SIG_FILE" ] && [ -f "release-files/$LINUX_SIG_FILE" ]; then
            LINUX_SIG=$(cat "release-files/$LINUX_SIG_FILE")
            echo "✅ Found Linux signature"
          else
            echo "⚠️ Missing Linux signature file"
          fi

          # Build platforms object conditionally
          # Start with empty platforms
          PLATFORMS=""

          if [ -n "$MACOS_ARM64_FILE" ]; then
            PLATFORMS="$PLATFORMS\"darwin-aarch64\": {\"signature\": \"$MACOS_ARM64_SIG\", \"url\": \"https://github.com/$REPO/releases/download/$TAG/$MACOS_ARM64_FILE\"},"
          fi

          if [ -n "$MACOS_X64_FILE" ]; then
            PLATFORMS="$PLATFORMS\"darwin-x86_64\": {\"signature\": \"$MACOS_X64_SIG\", \"url\": \"https://github.com/$REPO/releases/download/$TAG/$MACOS_X64_FILE\"},"
          fi

          if [ -n "$WINDOWS_FILE" ]; then
            PLATFORMS="$PLATFORMS\"windows-x86_64\": {\"signature\": \"$WINDOWS_SIG\", \"url\": \"https://github.com/$REPO/releases/download/$TAG/$WINDOWS_FILE\"},"
          fi

          if [ -n "$LINUX_FILE" ]; then
            PLATFORMS="$PLATFORMS\"linux-x86_64\": {\"signature\": \"$LINUX_SIG\", \"url\": \"https://github.com/$REPO/releases/download/$TAG/$LINUX_FILE\"},"
          fi

          # Remove trailing comma
          PLATFORMS="${PLATFORMS%,}"

          # Generate latest.json
          cat > release-files/latest.json <<EOF
          {
            "version": "${VERSION}",
            "notes": "See release notes at https://github.com/${REPO}/releases/tag/${TAG}",
            "pub_date": "${PUB_DATE}",
            "platforms": {
              ${PLATFORMS}
            }
          }
          EOF

          # Pretty print the JSON for verification
          echo "=== Generated latest.json ==="
          cat release-files/latest.json | python3 -m json.tool || cat release-files/latest.json

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.TAG }}
          name: Wingman ${{ steps.get_version.outputs.TAG }}
          generate_release_notes: true
          body: |
            ## Wingman ${{ steps.get_version.outputs.TAG }}

            A lightweight, cross-platform text composition tool with seamless auto-updates!

            ### Installation

            - **macOS (Apple Silicon):** Download `Wingman_*_aarch64.dmg`
            - **macOS (Intel):** Download `Wingman_*_x64.dmg`
            - **Windows:** Download `Wingman_*_x64-setup.exe` or `.msi`
            - **Linux:** Download `Wingman_*_amd64.deb` or `.AppImage`

            ### Auto-Updates

            After installing, Wingman will automatically check for updates. Click "Check for Updates" in Settings to download and install new versions seamlessly!

            ### Features

            - Global hotkey to summon floating editor
            - Syntax highlighting for 100+ languages
            - History and snippets
            - Multiple themes (Dark, Light, Solarized, Dracula, Nord)
            - In-app auto-updates
            
            ---
            ## Changes Since Last Release
          draft: false
          prerelease: false
          files: release-files/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
